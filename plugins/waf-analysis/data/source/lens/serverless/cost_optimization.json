[
  {
    "id": "SLSCOST01-BP01",
    "title_full": "SLSCOST01-BP01 Optimize Lambda function performance to reduce costs",
    "title": "Optimize Lambda function performance to reduce costs",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/cost-effective-resources.html",
    "description": "Optimize serverless application performance as it has a direct impact on cost due to the pay-per-value pricing model. Lambda allocates CPU, network, and storage IOPS proportionally based on memory, so faster initiation results in cheaper execution due to 1-ms billing incremental dimension.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST05-BP01"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP02",
    "title_full": "SLSCOST01-BP02 Right-size Lambda function memory for optimal cost-performance ratio",
    "title": "Right-size Lambda function memory for optimal cost-performance ratio",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/optimizing-over-time.html",
    "description": "Monitor and optimize Lambda function memory settings to find the optimal cost-performance balance. Higher memory allocations provide more CPU but cost more per millisecond. Use AWS Compute Optimizer and Lambda Power Tuning tools to identify optimal memory configurations.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST05-BP02"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP03",
    "title_full": "SLSCOST01-BP03 Optimize logging ingestion and storage costs",
    "title": "Optimize logging ingestion and storage costs",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/optimizing-over-time.html",
    "description": "Optimize CloudWatch Logs ingestion and storage by using appropriate logging levels, sampling mechanisms for DEBUG logs, and log retention policies. Consider using Amazon Kinesis Data Firehose and Amazon S3 for efficient log collection and lower-cost storage for large volumes.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST05-BP03"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP04",
    "title_full": "SLSCOST01-BP04 Leverage VPC endpoints to reduce data transfer costs",
    "title": "Leverage VPC endpoints to reduce data transfer costs",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/optimizing-over-time.html",
    "description": "Use VPC endpoints to reduce network costs by allowing secure access to AWS services without the need for an internet gateway or NAT instance. This eliminates data transfer charges for traffic between your VPC and AWS services.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST05-BP04"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP05",
    "title_full": "SLSCOST01-BP05 Choose appropriate DynamoDB capacity mode for cost optimization",
    "title": "Choose appropriate DynamoDB capacity mode for cost optimization",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/optimizing-over-time.html",
    "description": "Use DynamoDB on-demand capacity for unpredictable traffic to pay only for actual read and write usage. Use provisioned capacity with auto-scaling for predictable performance and costs on consistent workloads. Evaluate workload patterns to select the most cost-effective option.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST05-BP05"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP06",
    "title_full": "SLSCOST01-BP06 Use Step Functions Express Workflows for high-volume short-duration workloads",
    "title": "Use Step Functions Express Workflows for high-volume short-duration workloads",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/optimizing-over-time.html",
    "description": "Use AWS Step Functions Express Workflows for high-volume, short-duration orchestration to reduce costs compared to Standard Workflows. Express Workflows have lower per-execution costs and are billed by the number of requests and duration rather than state transitions.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST05-BP06"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP07",
    "title_full": "SLSCOST01-BP07 Use direct service integrations to reduce Lambda invocations",
    "title": "Use direct service integrations to reduce Lambda invocations",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/optimizing-over-time.html",
    "description": "Use direct integrations between services to reduce costs by eliminating the need for Lambda functions as intermediaries. API Gateway can directly integrate with DynamoDB, S3, and other services. Step Functions can directly call AWS services without Lambda.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST05-BP07"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP08",
    "title_full": "SLSCOST01-BP08 Optimize Lambda function code to reduce execution time",
    "title": "Optimize Lambda function code to reduce execution time",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/optimizing-over-time.html",
    "description": "Minimize Lambda function size and optimize code for cold starts to reduce execution time and costs. Use Lambda Layers for shared dependencies. Initialize external connections in global scope for reuse across invocations. Use efficient data serialization formats.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST05-BP08"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP09",
    "title_full": "SLSCOST01-BP09 Use resource tagging for cost allocation and visibility",
    "title": "Use resource tagging for cost allocation and visibility",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/expenditure-and-usage-awareness.html",
    "description": "As serverless architectures grow with more Lambda functions, APIs, and stages, use tagging to allocate costs from your AWS bill to individual functions and APIs. Share the same key-value tag for assets belonging to a project programmatically, and create custom reports in AWS Cost Explorer based on tags.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Expenditure and usage awareness"],
    "relatedIds": ["COST02-BP01"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSCOST01-BP10",
    "title_full": "SLSCOST01-BP10 Use data-driven decisions over haste-guided over-provisioning",
    "title": "Use data-driven decisions over haste-guided over-provisioning",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/cost-optimization.html",
    "description": "Avoid over-provisioning based on haste or fear of under-capacity. Use empirical data and benchmarking to make design decisions rather than overcompensating 'just in case'. Serverless reduces capacity planning effort through pay-per-value pricing and scale-on-demand, but tradeoffs still exist.",
    "outcome": "",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": ["COST01-BP01"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  }
]
