[
  {
    "id": "SLSREL01-BP01",
    "title_full": "SLSREL01-BP01 Enable API Gateway throttling to enforce access patterns",
    "title": "Enable API Gateway throttling to enforce access patterns",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "Enable throttling at the API level to enforce access patterns established by service contracts. Define a request access pattern strategy at the resource or global level. Return appropriate HTTP status codes (such as 429 for throttling) to help consumers plan for throttled access by implementing back-off and retries accordingly.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Regulating inbound request rates"],
    "relatedIds": ["REL10-BP01"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL01-BP02",
    "title_full": "SLSREL01-BP02 Use API keys with usage plans for granular throttling and metering",
    "title": "Use API keys with usage plans for granular throttling and metering",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "For granular throttling and metering usage, issue API keys to consumers with usage plans in addition to global throttling. This enables API Gateway to enforce quota and access patterns in unexpected behavior. API keys simplify cutting off access if an individual consumer makes suspicious requests. Consider a developer portal to capture application and contact information.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Regulating inbound request rates"],
    "relatedIds": ["REL10-BP02"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL01-BP03",
    "title_full": "SLSREL01-BP03 Use Lambda concurrency controls to protect backend systems",
    "title": "Use Lambda concurrency controls to protect backend systems",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "Use Lambda concurrency controls to protect specific workloads against service failure when backend systems may not scale as rapidly as Lambda. Use for scenarios including: sensitive backend systems with scaling limitations, protection against recursive invocations, database connection pool restrictions, ensuring critical path services don't run out of concurrency, and DDoS protection.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Regulating inbound request rates"],
    "relatedIds": ["REL10-BP03"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL01-BP04",
    "title_full": "SLSREL01-BP04 Use Amazon RDS Proxy for Lambda database connections",
    "title": "Use Amazon RDS Proxy for Lambda database connections",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "When Lambda functions access Amazon RDS databases, use Amazon RDS Proxy as a connection pooling mechanism to manage concurrent connections efficiently. This prevents database connection pool restrictions from being exceeded while allowing Lambda functions to scale.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Regulating inbound request rates"],
    "relatedIds": ["REL10-BP04"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL01-BP05",
    "title_full": "SLSREL01-BP05 Use Kinesis Data Streams to control asynchronous processing concurrency",
    "title": "Use Kinesis Data Streams to control asynchronous processing concurrency",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "For asynchronous processing, use Kinesis Data Streams to effectively control concurrency with a single shard instead of Lambda function concurrency controls. This provides flexibility to increase the number of shards or the parallelization factor to increase concurrency of your Lambda function.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Regulating inbound request rates"],
    "relatedIds": ["REL10-BP05"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP01",
    "title_full": "SLSREL02-BP01 Use asynchronous calls and event-driven architectures",
    "title": "Use asynchronous calls and event-driven architectures",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "Asynchronous calls reduce latency on HTTP responses. Multiple synchronous calls and long-running wait cycles may result in timeouts and locked code that prevents retry logic. Event-driven architectures enable streamlining asynchronous initiations using queues, streams, pub/sub, webhooks, state machines, and event rule managers.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Building resiliency"],
    "relatedIds": ["REL11-BP01"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP02",
    "title_full": "SLSREL02-BP02 Manage transaction, partial, and intermittent failures",
    "title": "Manage transaction, partial, and intermittent failures",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "Handle transaction failures under high load, partial failures during batch processing, and intermittent failures from network or transient issues. Process partial failures in non-atomic operations like PutRecords (Kinesis) and BatchWriteItem (DynamoDB) by always inspecting the response and programmatically dealing with failed items.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Building resiliency"],
    "relatedIds": ["REL11-BP02"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP03",
    "title_full": "SLSREL02-BP03 Manage duplicate and unwanted events with idempotency",
    "title": "Manage duplicate and unwanted events with idempotency",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "Design applications to process multiple identical requests with the same effect as making a single request (idempotency). Duplicate events can occur when requests are retried, multiple consumers process the same message from a queue or stream, or requests are sent twice with the same parameters. Discard events not adhering to your schema.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Building resiliency"],
    "relatedIds": ["REL11-BP03"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP04",
    "title_full": "SLSREL02-BP04 Use dead-letter queues to capture and retry failed transactions",
    "title": "Use dead-letter queues to capture and retry failed transactions",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/failure-management.html",
    "description": "Use dead-letter queue mechanisms to retain, investigate, and retry failed transactions. AWS Lambda allows failed transactions to be sent to a dedicated Amazon SQS dead-letter queue per function. Configure Maximum Retry Attempts, Maximum Record Age, and Destination on Failure to control retry behavior and remove poison-pill messages.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Failure management"],
    "relatedIds": ["REL11-BP04"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP05",
    "title_full": "SLSREL02-BP05 Use Step Functions for orchestrating long-running transactions",
    "title": "Use Step Functions for orchestrating long-running transactions",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "Favor state machines for long-running transactions instead of handling them within application code in a single component or multiple synchronous dependency call chains. Use Step Functions to coordinate business transactions across multiple services, control states, and handle error handling. For synchronous calls, ensure total run time doesn't exceed API Gateway or AppSync timeouts.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Failure management"],
    "relatedIds": ["REL11-BP05"],
    "risk": "HIGH",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP06",
    "title_full": "SLSREL02-BP06 Implement the Saga pattern for distributed transaction rollback",
    "title": "Implement the Saga pattern for distributed transaction rollback",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/failure-management.html",
    "description": "For synchronous transaction-based operations with certain guarantees and requirements, implement rolling back failed transactions using the Saga pattern with Step Functions state machines. This decouples and simplifies application logic while ensuring data consistency across distributed services.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Failure management"],
    "relatedIds": ["REL11-BP06"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP07",
    "title_full": "SLSREL02-BP07 Review and tune SDK back-off and retry settings",
    "title": "Review and tune SDK back-off and retry settings",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/failure-management.html",
    "description": "While AWS SDKs provide default back-off and retry mechanisms, review and tune them to suit your needs, especially HTTP keepalive, connection, and socket timeouts. Don't rely on default timeouts; tune them to fail fast if socket read/write timeouts happen where defaults can be seconds or minutes.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Failure management"],
    "relatedIds": ["REL11-BP07"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP08",
    "title_full": "SLSREL02-BP08 Choose appropriate Step Functions workflow type for your workload",
    "title": "Choose appropriate Step Functions workflow type for your workload",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/failure-management.html",
    "description": "Choose the Step Functions type based on your workload characteristics. Use Step Functions Express Workflows for short-running synchronous and asynchronous high-volume workloads. Use Step Functions Standard for long-running workflows requiring additional durability and audit capabilities.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Failure management"],
    "relatedIds": ["REL11-BP08"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  },
  {
    "id": "SLSREL02-BP09",
    "title_full": "SLSREL02-BP09 Consider scaling patterns at burst rates",
    "title": "Consider scaling patterns at burst rates",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/rel-foundations.html",
    "description": "In addition to baseline performance, evaluate how your workload handles initial burst rates that may be expected or unexpected peaks. Design for and test against traffic spikes to ensure your serverless application can handle sudden increases in load.",
    "outcome": "",
    "pillar": "RELIABILITY",
    "area": ["Building resiliency"],
    "relatedIds": ["REL11-BP09"],
    "risk": "MEDIUM",
    "lens": "SERVERLESS"
  }
]
