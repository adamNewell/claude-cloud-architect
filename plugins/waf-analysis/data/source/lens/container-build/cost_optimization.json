[
  {
    "id": "CBLDCOST01-BP01",
    "title_full": "CBLDCOST01-BP01 Delete old container images to save costs",
    "title": "Delete old container images to save costs",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/practice-cloud-financial-management.html",
    "description": "Building a containerized application can result in multiple images for the same service. Depending on your organization policy, you might want to keep a subset of your container images for rollback scenarios. Not all container images of a specific application should be kept. Deleting old images can save costs as container registries charge by size of images stored. Create automation processes or use service features like Amazon ECR lifecycle policies to expire (delete) images based on rules such as image age, count, specific tags and more.",
    "outcome": "Reduces storage costs by automatically removing obsolete container images while maintaining necessary rollback capabilities.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Practice cloud financial management"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST02-BP01",
    "title_full": "CBLDCOST02-BP01 Minimize unnecessary application dependencies",
    "title": "Minimize unnecessary application dependencies",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/expenditure-and-usage-awareness.html",
    "description": "The container image is usually built alongside with the application build step. During this build step, all necessary dependencies, libraries, and modules used by the application code are downloaded to the container image. Using unnecessary dependencies will make the build time longer and will result in wasting compute resources of the build system.",
    "outcome": "Reduces build time and compute costs by including only necessary dependencies in container images.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Expenditure and usage awareness"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST02-BP02",
    "title_full": "CBLDCOST02-BP02 Build common container image dependencies into parent images",
    "title": "Build common container image dependencies into parent images",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/expenditure-and-usage-awareness.html",
    "description": "Some operating system packages are needed for multiple applications in the organization for a specific runtime. Building a parent container image that preinstalls all common operating system packages and dependencies for the specific runtime will result in a more efficient build process. Without this common image, each individual container image would be installing the same packages, thus wasting compute and network resources. This practice will also shorten the time for container images built from a specific runtime.",
    "outcome": "Reduces build costs and time by reusing common dependencies across multiple container images.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Expenditure and usage awareness"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST03-BP01",
    "title_full": "CBLDCOST03-BP01 Ensure container images contain only what is relevant for your application to run",
    "title": "Ensure container images contain only what is relevant for your application to run",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/cost-effective-resources.html",
    "description": "Container image size affects the time needed for an image to be pulled from a container registry. Large image sizes can lead to slow startup time of the application, which can waste compute resources while waiting for images to be pulled and slow scale-out operations. Container image size also affects scaling time needed for a containerized application to become ready to receive traffic. In autoscaled environments, delays can result in hundreds of compute minutes wasted per month.",
    "outcome": "Reduces costs by minimizing container startup time and wasted compute resources during scaling operations.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST03-BP02",
    "title_full": "CBLDCOST03-BP02 Optimize storage requirements for containers",
    "title": "Optimize storage requirements for containers",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/cost-effective-resources.html",
    "description": "Consider your instance's storage requirements depending on your container image size. The size of your container image has a direct effect on the instance storage size that the container will run on, which can result in the need for larger storage size for your instances. Container image size also affects the storage requirements of the container registry. Stored images in Amazon ECR are priced per GB-month.",
    "outcome": "Reduces storage costs for both compute instances and container registries by optimizing image sizes.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST04-BP01",
    "title_full": "CBLDCOST04-BP01 Reduce container image layers by concatenating commands",
    "title": "Reduce container image layers by concatenating commands",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/cost-effective-resources.html",
    "description": "A container image consists of read-only layers representing Dockerfile instructions. Running multiple consecutive commands can result in large container image size, even if you delete content in the container image. Concatenate commands using one-liner approach to install packages and remove cached files in a single command. This reduces the number of layers and overall image size.",
    "outcome": "Reduces container image size and associated storage costs by minimizing the number of image layers.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST04-BP02",
    "title_full": "CBLDCOST04-BP02 Use techniques to reduce container image size",
    "title": "Use techniques to reduce container image size",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/cost-effective-resources.html",
    "description": "Reduce image layers using several techniques: building from scratch image for minimal size, using lightweight base images like Alpine, reducing the number of RUN instructions by chaining commands, using package manager flags to reduce dependency sizes (like no-install-recommends), using multi-stage builds, and following Dockerfile best practices (use COPY instead of ADD, use absolute paths with WORKDIR, exclude files using .dockerignore).",
    "outcome": "Significantly reduces container image size through multiple optimization techniques, lowering storage and transfer costs.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST05-BP01",
    "title_full": "CBLDCOST05-BP01 Design containerized applications to handle SIGTERM signals for graceful termination",
    "title": "Design containerized applications to handle SIGTERM signals for graceful termination",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/cost-effective-resources.html",
    "description": "When designing applications that will be containerized, include signal handling within the code and/or the container itself. Handling signals is fundamental for writing applications in containers. The application should handle system signals and react according to the application logic. Although not directly related to cost, handling signals is a key element for using cost saving practices like automatic scaling or using Amazon EC2 Spot Instances. When a scale-in or Spot termination occurs, the orchestrator sends a SIGTERM signal for graceful shutdown.",
    "outcome": "Enables use of cost-saving features like autoscaling and Spot Instances by ensuring graceful container termination.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST06-BP01",
    "title_full": "CBLDCOST06-BP01 Support multiple CPU architectures for cost optimization",
    "title": "Support multiple CPU architectures for cost optimization",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/cost-effective-resources.html",
    "description": "Different instance families offer different performance for the same amount of hardware. To use different instance architectures like ARM, change your build process to create multiple images for each CPU architecture. Run the build process on both x86 and ARM-based instances, using tagging suffixes to differentiate. Use Docker image manifest v2 schema 2 or OCI image index specification to create a high-level manifest containing references to all different container images, allowing the container runtime to automatically pull the correct image based on the instance architecture.",
    "outcome": "Enables use of cost-effective instance types like Graviton by supporting multiple CPU architectures.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Cost-effective resources"],
    "relatedIds": [],
    "risk": "LOW",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST07-BP01",
    "title_full": "CBLDCOST07-BP01 Minimize startup time by including dependencies in the build process",
    "title": "Minimize startup time by including dependencies in the build process",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/manage-demand-and-supply-resources.html",
    "description": "Longer startup times for containerized applications can result in wasted compute resources. Shorten startup times on the application-level (code optimization) or on the container level. If the application needs external dependencies to be present in the container, they should be installed during the build process or included in the parent image, not downloaded at startup using an entrypoint script or DOCKERFILE commands.",
    "outcome": "Reduces compute waste by minimizing container startup time through pre-built dependencies.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Manage demand and supply resources"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDCOST08-BP01",
    "title_full": "CBLDCOST08-BP01 Use managed build services to reduce operational costs",
    "title": "Use managed build services to reduce operational costs",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/manage-demand-and-supply-resources.html",
    "description": "Creating any build process requires developing, maintaining, and operating a build system. This can be done using OSS tooling for job automation or self-developed systems. However, running and maintaining this kind of system involves software development costs, operational costs, and compute and storage costs. Alternatively, use build and pipeline services such as Amazon EC2 Image Builder, AWS CodeBuild, and AWS CodePipeline. Using managed services removes the operational overhead and allows developers to consume pipeline runs and build jobs on a pay-as-you-go basis.",
    "outcome": "Reduces operational and infrastructure costs by leveraging managed build services instead of self-hosted solutions.",
    "pillar": "COST_OPTIMIZATION",
    "area": ["Manage demand and supply resources"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  }
]
