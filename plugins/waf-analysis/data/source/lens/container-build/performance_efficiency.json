[
  {
    "id": "CBLDPER01-BP01",
    "title_full": "CBLDPER01-BP01 Use small parent images",
    "title": "Use small parent images",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/selection.html",
    "description": "The OS parent image that is used to create the target images has a huge impact on the final container image size. Use Alpine or scratch base images to build performant containers. For statically linked binaries, scratch can be an alternative. With a multi-stage build and using scratch as a base image, you can achieve the smallest possible target image for running your application.",
    "outcome": "Significantly reduces container image size, improving build and deployment performance.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Selection"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDPER01-BP02",
    "title_full": "CBLDPER01-BP02 Run a single process per container",
    "title": "Run a single process per container",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/selection.html",
    "description": "It is highly recommended to limit the number of processes in each container to one. This approach simplifies the implementation of separation of concerns using simple services. Each container should only be responsible for a single aspect of the application that facilitates horizontal scaling of this particular aspect. If it's necessary to run more than one process per container, use a proper process supervisor (like supervisord) and an init system (like tini).",
    "outcome": "Improves scalability and simplifies container management by following separation of concerns principles.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Selection"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDPER01-BP03",
    "title_full": "CBLDPER01-BP03 Exclude files from your build process using .dockerignore",
    "title": "Exclude files from your build process using .dockerignore",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/selection.html",
    "description": "The .dockerignore file is similar to .gitignore and is used to exclude files that are not necessary for the build, or are of a sensitive nature. This can be useful if it's not possible to restructure the source code directory to limit the build context. Exclude files like compilation target directories, JAR files, and subdirectories that are not needed for the build.",
    "outcome": "Reduces build context size and improves build performance while protecting sensitive files.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Selection"],
    "relatedIds": [],
    "risk": "LOW",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDPER01-BP04",
    "title_full": "CBLDPER01-BP04 Use a container registry close to your cluster",
    "title": "Use a container registry close to your cluster",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/selection.html",
    "description": "One of the essential factors in the speed of deploying container images from a registry is locality. The registry should be as close to the cluster as possible, which means that both the cluster and the registry should be in the same AWS Region. For multi-region deployments, the CI/CD chain should publish a container image to multiple Regions. Keep the container image as small as possible to optimize pull time.",
    "outcome": "Reduces image pull time and improves deployment speed through geographic proximity and smaller image sizes.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Selection"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDPER02-BP01",
    "title_full": "CBLDPER02-BP01 Avoid using the 'latest' tag for parent images",
    "title": "Avoid using the 'latest' tag for parent images",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/review.html",
    "description": "Using the 'latest' tag for the parent image could potentially lead to issues because the latest version of the image might include breaking changes compared to the version that is currently used. Use specific version tags to ensure consistent and predictable builds.",
    "outcome": "Ensures build consistency and prevents unexpected breaking changes from parent image updates.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Review"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDPER02-BP02",
    "title_full": "CBLDPER02-BP02 Implement a notification mechanism for updated parent images",
    "title": "Implement a notification mechanism for updated parent images",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/review.html",
    "description": "If you're using a team- or enterprise-wide image, implement a notification mechanism as part of your CI/CD chain to distribute information about a new parent image to the teams. The teams should build target images with the new parent images and measure the performance impact of the changes by running a proper test suite.",
    "outcome": "Enables proactive management of parent image updates and performance validation.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Review"],
    "relatedIds": [],
    "risk": "LOW",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDPER03-BP01",
    "title_full": "CBLDPER03-BP01 Implement an automated performance testing strategy",
    "title": "Implement an automated performance testing strategy",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/monitoring.html",
    "description": "System performance can degrade over time. Have an automated testing and monitoring system in place to identify degradation of performance. Every time you build target images based on new parent images, measure the performance impact of the changes. This includes the overall build process and CI/CD chain. Performance metrics and image sizes should be collected using services like Amazon CloudWatch and teams must be alarmed if anomalies have been detected.",
    "outcome": "Detects performance degradation early through continuous monitoring and automated testing.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Monitoring"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDPER04-BP01",
    "title_full": "CBLDPER04-BP01 Use caching during build",
    "title": "Use caching during build",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/tradeoffs.html",
    "description": "A container image is created using layers. Each statement in a Dockerfile creates a new layer that can be stored in a local image cache and reused in the next build. The order of commands in your Dockerfile can have a dramatic effect on build performance. Place frequently changing statements (like COPY for application code) after less frequently changing statements (like RUN for installing dependencies) to maximize cache utilization and reduce build time.",
    "outcome": "Significantly improves build performance by maximizing layer cache utilization.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Tradeoffs"],
    "relatedIds": [],
    "risk": "MEDIUM",
    "lens": "CONTAINER_BUILD"
  },
  {
    "id": "CBLDPER04-BP02",
    "title_full": "CBLDPER04-BP02 Use the CPU architecture with best price to performance ratio",
    "title": "Use the CPU architecture with best price to performance ratio",
    "href": "https://docs.aws.amazon.com/wellarchitected/latest/container-build-lens/tradeoffs.html",
    "description": "AWS Graviton-based Amazon EC2 instances deliver up to 40% better price performance over comparable current generation x86-based instances. Instead of using one build-server for x86 and ARM with CPU emulation, use at least one build server per CPU architecture. Create multi-architecture container images to support AWS Graviton-based instances and x86 using AWS CodeBuild and AWS CodePipeline with separate build projects and a manifest list.",
    "outcome": "Optimizes build performance and cost by using native CPU architectures for multi-architecture support.",
    "pillar": "PERFORMANCE_EFFICIENCY",
    "area": ["Tradeoffs"],
    "relatedIds": [],
    "risk": "LOW",
    "lens": "CONTAINER_BUILD"
  }
]
